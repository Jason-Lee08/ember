"""Graph Executor Module.

Provides data structures and execution routines for network-of-network (NoN) operator graphs.

"""

from __future__ import annotations

import logging
from collections import deque
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Union

from ember.core.registry.operator.core.operator_base import Operator
from ember.core.registry.operator.operator_registry import OperatorRegistry
from ember.core.registry.model.core.modules.lm_modules import LMModule, LMModuleConfig

LOGGER: logging.Logger = logging.getLogger(__name__)


##############################################
# Graph Data Structures
##############################################


@dataclass(frozen=True)
class GraphNode:
    """Represents a single node in a network-of-network (NoN) graph.

    Attributes:
        name (str): The unique identifier for the node.
        operator (Union[Operator, NoNGraphData]): The operator or subgraph associated with this node.
        inputs (List[str]): A list of node names whose outputs feed into this node.
    """

    name: str
    operator: Union[Operator, NoNGraphData]
    inputs: List[str] = field(default_factory=list)


@dataclass
class NoNGraphData:
    """Represents a network-of-network (NoN) graph as a mapping of node names to GraphNode instances.

    This data structure holds the graph's nodes without embedding execution logic.

    Attributes:
        nodes (Dict[str, GraphNode]): A dictionary mapping node names to GraphNode instances.
    """

    nodes: Dict[str, GraphNode] = field(default_factory=dict)

    def add_node(
        self, *, name: str, operator: Union[Operator, NoNGraphData], inputs: List[str]
    ) -> None:
        """Adds a node to the graph.

        Args:
            name (str): Unique identifier for the node.
            operator (Union[Operator, NoNGraphData]): Processing operator or subgraph for the node.
            inputs (List[str]): List of node names whose outputs feed into this node.

        Raises:
            ValueError: If a node with the given name already exists.
        """
        if name in self.nodes:
            raise ValueError(f"Node '{name}' already exists in the graph.")
        self.nodes[name] = GraphNode(name=name, operator=operator, inputs=inputs)


##############################################
# Graph Execution Core
##############################################


class GraphExecutor:
    """Executes a NoNGraphData graph by performing a topological sort and executing each operator.

    For single-node graphs, execution is direct. For multi-node graphs, execution is layered
    based on a topologically sorted order.

    Attributes:
        max_workers (Optional[int]): Maximum number of worker threads for parallel execution.
    """

    def __init__(self, *, max_workers: Optional[int] = None) -> None:
        """Initializes the GraphExecutor.

        Args:
            max_workers (Optional[int]): Maximum number of worker threads for parallel execution.
                Defaults to None.
        """
        self.max_workers: Optional[int] = max_workers

    def execute(
        self, *, graph_data: NoNGraphData, input_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Executes the graph and returns the output from the final node.

        For a single-node graph, node execution is immediate; for multi-node graphs, nodes are executed
        in layers based on topological order.

        Args:
            graph_data (NoNGraphData): The graph to execute.
            input_data (Dict[str, Any]): The initial input data for execution.

        Returns:
            Dict[str, Any]: The output generated by the final node.

        Raises:
            ValueError: If the graph contains a cycle or is not a valid directed acyclic graph (DAG).
        """
        if len(graph_data.nodes) == 1:
            single_node: GraphNode = next(iter(graph_data.nodes.values()))
            LOGGER.debug(
                "Single-node graph detected; executing node '%s' immediately.",
                single_node.name,
            )
            return self._execute_node(
                node=single_node, results={}, input_data=input_data
            )

        LOGGER.debug("Performing topological sort for multi-node graph execution.")
        sorted_nodes: List[str] = self._topological_sort(graph_data=graph_data)
        results: Dict[str, Dict[str, Any]] = {}

        LOGGER.debug("Starting layered execution plan.")
        for layer in self._layered_execution_plan(
            graph_data=graph_data, sorted_nodes=sorted_nodes
        ):
            layer_results: Dict[str, Dict[str, Any]] = {}
            for node_name in layer:
                node: GraphNode = graph_data.nodes[node_name]
                LOGGER.debug("Collecting inputs for node '%s'.", node_name)
                node_inputs: Dict[str, Any] = self._collect_inputs(
                    node=node, results=results, input_data=input_data
                )
                node_result: Dict[str, Any] = self._execute_node(
                    node=node, results=results, input_data=node_inputs
                )
                layer_results[node_name] = node_result
            results.update(layer_results)

        final_node: str = sorted_nodes[-1]
        LOGGER.debug(
            "Execution completed; returning output for final node '%s'.", final_node
        )
        return results[final_node]

    def _execute_node(
        self,
        *,
        node: GraphNode,
        results: Dict[str, Dict[str, Any]],
        input_data: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Executes a single node within the graph.

        If the node's operator is a subgraph, this method performs recursive execution.

        Args:
            node (GraphNode): The node to execute.
            results (Dict[str, Dict[str, Any]]): Results from prior node executions.
            input_data (Dict[str, Any]): Input data for the node's operator.

        Returns:
            Dict[str, Any]: The output from the node's execution.
        """
        LOGGER.debug("Executing node '%s'.", node.name)
        if isinstance(node.operator, NoNGraphData):
            LOGGER.debug(
                "Node '%s' operator is a subgraph; executing recursively.", node.name
            )
            sub_executor: GraphExecutor = GraphExecutor(max_workers=self.max_workers)
            return sub_executor.execute(graph_data=node.operator, input_data=input_data)
        return node.operator(**input_data)

    def _topological_sort(self, *, graph_data: NoNGraphData) -> List[str]:
        """Performs a topological sort on the graph using an in-degree algorithm.

        Args:
            graph_data (NoNGraphData): The graph to sort.

        Returns:
            List[str]: A list of node names in topologically sorted order.

        Raises:
            ValueError: If the graph contains a cycle or is not a valid DAG.
        """
        in_degree: Dict[str, int] = {}
        successors: Dict[str, List[str]] = {
            node_name: [] for node_name in graph_data.nodes
        }
        for node in graph_data.nodes.values():
            in_degree[node.name] = len(node.inputs)
            for input_node in node.inputs:
                if input_node not in graph_data.nodes:
                    error_message: str = (
                        f"Input node '{input_node}' for node '{node.name}' not found in graph."
                    )
                    LOGGER.error(error_message)
                    raise ValueError(error_message)
                successors[input_node].append(node.name)

        node_queue: deque[str] = deque([n for n, deg in in_degree.items() if deg == 0])
        sorted_list: List[str] = []

        while node_queue:
            current_node: str = node_queue.popleft()
            sorted_list.append(current_node)
            for successor in successors[current_node]:
                in_degree[successor] -= 1
                if in_degree[successor] == 0:
                    node_queue.append(successor)

        if len(sorted_list) != len(graph_data.nodes):
            error_msg: str = "Graph contains a cycle or is not a valid DAG."
            LOGGER.error(error_msg)
            raise ValueError(error_msg)
        return sorted_list

    def _layered_execution_plan(
        self, *, graph_data: NoNGraphData, sorted_nodes: List[str]
    ) -> List[List[str]]:
        """Generates a layered execution plan preserving topological order.

        Currently, each node is assigned its own layer. Future optimizations may group independent nodes
        for parallel execution.

        Args:
            graph_data (NoNGraphData): The graph data.
            sorted_nodes (List[str]): A list of topologically sorted node names.

        Returns:
            List[List[str]]: Layers of node names, each layer represented as a list.
        """
        LOGGER.debug("Generating layered execution plan with one node per layer.")
        return [[node_name] for node_name in sorted_nodes]

    def _collect_inputs(
        self,
        *,
        node: GraphNode,
        results: Dict[str, Dict[str, Any]],
        input_data: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Aggregates inputs for a node from prior execution results and initial input data.

        Args:
            node (GraphNode): The node for which inputs are aggregated.
            results (Dict[str, Dict[str, Any]]): Previously executed nodes and their outputs.
            input_data (Dict[str, Any]): The initial input data for the graph.

        Returns:
            Dict[str, Any]: The combined input data for the node's operator.
        """
        if isinstance(node.operator, NoNGraphData):
            LOGGER.debug(
                "Node '%s' operator is a subgraph; using initial input data directly.",
                node.name,
            )
            return input_data

        operator_instance: Operator = node.operator  # type: ignore
        operator_signature: Any = operator_instance.get_signature()
        required_inputs: List[str] = (
            operator_signature.required_inputs if operator_signature else []
        )
        combined_inputs: Dict[str, Any] = dict(input_data)

        if "responses" in required_inputs:
            LOGGER.debug("Collecting 'responses' for node '%s'.", node.name)
            gathered_responses: List[Any] = []
            for input_node in node.inputs:
                input_result: Dict[str, Any] = results.get(input_node, {})
                if "responses" in input_result and isinstance(
                    input_result.get("responses"), list
                ):
                    gathered_responses.extend(input_result["responses"])
                elif "final_answer" in input_result:
                    gathered_responses.append(input_result["final_answer"])
            combined_inputs["responses"] = gathered_responses

        if "query" in required_inputs and "query" not in combined_inputs:
            LOGGER.debug(
                "Node '%s' requires 'query'; retrieving it from the initial inputs.",
                node.name,
            )
            if "query" in input_data:
                combined_inputs["query"] = input_data["query"]

        return combined_inputs


##############################################
# High-Level Execution Service
##############################################


class GraphExecutorService:
    """Service wrapper for the GraphExecutor that centralizes logging and error handling."""

    def __init__(self, *, max_workers: Optional[int] = None) -> None:
        """Initializes the GraphExecutorService.

        Args:
            max_workers (Optional[int]): Maximum number of worker threads for parallel execution.
        """
        self._executor_core: GraphExecutor = GraphExecutor(max_workers=max_workers)
        self._logger: logging.Logger = logging.getLogger(self.__class__.__name__)

    def run(
        self, *, graph_data: NoNGraphData, input_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Executes the graph with robust logging and error management.

        Args:
            graph_data (NoNGraphData): The graph to execute.
            input_data (Dict[str, Any]): Input data required for execution.

        Returns:
            Dict[str, Any]: The final output from the graph execution.

        Raises:
            Exception: Propagates any encountered exception during execution.
        """
        self._logger.info("GraphExecutorService run initiated.")
        try:
            result: Dict[str, Any] = self._executor_core.execute(
                graph_data=graph_data, input_data=input_data
            )
            self._logger.info("Graph execution completed successfully.")
            return result
        except Exception as exc:
            self._logger.error("Graph execution failed: %s", str(exc), exc_info=True)
            raise


##############################################
# NoNGraph Builder (Dictionary-based)
##############################################


class NoNGraphBuilder:
    """Constructs a NoNGraphData instance from a dictionary-based specification.

    The expected configuration format is:
        {
            "node_name": {
                "op": "ENSEMBLE",
                "params": {"model_name": "gpt-4o", "temperature": 1.0, "count": 3},
                "inputs": ["other_node", ...]
            },
            ...
        }
    """

    def __init__(self) -> None:
        """Initializes the NoNGraphBuilder with an empty graph."""
        self._graph_data: NoNGraphData = NoNGraphData()

    def parse_graph(
        self, *, graph: Dict[str, Dict[str, Any]], **kwargs: Any
    ) -> NoNGraphData:
        """Parses a dictionary configuration into a NoNGraphData instance.

        Args:
            graph (Dict[str, Dict[str, Any]]): Dictionary describing the graph nodes.
            **kwargs: Additional parameters for future extensions.

        Returns:
            NoNGraphData: The constructed graph data instance.
        """
        return self._build_graph(config=graph, **kwargs)

    def _build_graph(
        self, *, config: Dict[str, Dict[str, Any]], **kwargs: Any
    ) -> NoNGraphData:
        """Builds a NoNGraphData instance from the provided configuration.

        Args:
            config (Dict[str, Dict[str, Any]]): Dictionary mapping node names to node configurations.
            **kwargs: Additional parameters for future extensions.

        Returns:
            NoNGraphData: The constructed graph.
        """
        for name, node_config in config.items():
            op_entry: Optional[str] = node_config.get("op")
            if op_entry is None:
                raise ValueError(
                    f"Node '{name}' configuration must include an 'op' entry."
                )
            params: Dict[str, Any] = node_config.get("params", {})
            inputs: List[str] = node_config.get("inputs", [])

            operator_class = OperatorRegistry.get(op_entry)
            lm_modules: List[LMModule] = self._create_lm_modules_from_params(
                params=params
            )

            op_instance: Operator = operator_class(lm_modules=lm_modules)
            self._graph_data.add_node(name=name, operator=op_instance, inputs=inputs)
        return self._graph_data

    def _create_lm_modules_from_params(
        self, *, params: Dict[str, Any]
    ) -> List[LMModule]:
        """Creates LMModule instances based on the provided parameters.

        Args:
            params (Dict[str, Any]): Parameters possibly including 'model_name', 'temperature',
                'max_tokens', 'persona', and 'count'.

        Returns:
            List[LMModule]: A list of LMModule instances if 'model_name' is present; otherwise, an empty list.
        """
        if "model_name" not in params:
            return []
        params_copy: Dict[str, Any] = dict(params)
        count: int = params_copy.pop("count", 1)
        config_for_lm: Dict[str, Any] = {
            k: v
            for k, v in params_copy.items()
            if k in ["model_name", "temperature", "max_tokens", "persona"]
        }
        return [LMModule(LMModuleConfig(**config_for_lm)) for _ in range(count)]


##############################################
# DSL for Graph Building (Alternative Approach)
##############################################


class GraphNodeBuilder:
    """DSL builder for configuring a single graph node.

    This builder allows setting the operator, parameters, and inputs, then integrates the node into
    the parent NoNGraphData.
    """

    def __init__(self, *, graph_builder: GraphBuilder, name: str) -> None:
        """Initializes the GraphNodeBuilder.

        Args:
            graph_builder (GraphBuilder): The parent builder instance managing graph construction.
            name (str): Unique name for the node.
        """
        self.graph_builder: GraphBuilder = graph_builder
        self.name: str = name
        self._op_code: Optional[str] = None
        self._params: Dict[str, Any] = {}
        self._inputs: List[str] = []

    def operator(self, *, op_code: str) -> GraphNodeBuilder:
        """Specifies the operator code for this node.

        Args:
            op_code (str): The operator identifier (e.g., 'ENSEMBLE' or 'JUDGE').

        Returns:
            GraphNodeBuilder: Self for fluent chaining.
        """
        self._op_code = op_code
        return self

    def params(self, **kwargs: Any) -> GraphNodeBuilder:
        """Sets or updates parameters for the node's operator.

        Args:
            **kwargs: Keyword arguments representing operator parameters.

        Returns:
            GraphNodeBuilder: Self for method chaining.
        """
        self._params.update(kwargs)
        return self

    def inputs(self, *nodes: str) -> GraphNodeBuilder:
        """Specifies input node names for this node.

        Args:
            *nodes (str): Names of nodes whose outputs will serve as inputs.

        Returns:
            GraphNodeBuilder: Self for method chaining.
        """
        self._inputs.extend(nodes)
        return self

    def build(self) -> None:
        """Finalizes the node configuration and adds it to the parent graph.

        Raises:
            ValueError: If the operator code has not been defined.
        """
        if self._op_code is None:
            raise ValueError(f"Node '{self.name}' has no operator defined.")

        operator_class = OperatorRegistry.get(self._op_code)
        lm_modules: List[LMModule] = []
        if "model_name" in self._params:
            count: int = self._params.pop("count", 1)
            config_for_lm: Dict[str, Any] = {
                k: v
                for k, v in self._params.items()
                if k in ["model_name", "temperature", "max_tokens", "persona"]
            }
            config_for_lm.setdefault("model_name", "gpt-4-turbo")
            config_for_lm.setdefault("temperature", 1.0)
            for _ in range(count):
                lm_modules.append(LMModule(LMModuleConfig(**config_for_lm)))
        op_instance: Operator = operator_class(lm_modules=lm_modules)
        self.graph_builder._graph_data.add_node(
            name=self.name, operator=op_instance, inputs=self._inputs
        )


class GraphBuilder:
    """DSL-based builder for constructing network-of-network graphs.

    Provides a fluent interface for adding nodes and generating a complete NoNGraphData instance.
    """

    def __init__(self) -> None:
        """Initializes the GraphBuilder with an empty graph."""
        self._graph_data: NoNGraphData = NoNGraphData()

    def node(self, *, name: str) -> GraphNodeBuilder:
        """Begins construction of a new node.

        Args:
            name (str): Unique name of the node.

        Returns:
            GraphNodeBuilder: A builder for configuring the node.
        """
        return GraphNodeBuilder(graph_builder=self, name=name)

    def build(self) -> NoNGraphData:
        """Finalizes the construction of the graph.

        Returns:
            NoNGraphData: The complete graph with all configured nodes.
        """
        return self._graph_data


##############################################
# Example Usage
##############################################

# if __name__ == "__main__":
#     logging.basicConfig(level=logging.INFO)
#
#     # Use DSL to build a graph.
#     builder: GraphBuilder = GraphBuilder()
#
#     builder.node(name="ensemble1") \
#         .operator(op_code="ENSEMBLE") \
#         .params(model_name="gpt-4o", count=3) \
#         .build()
#
#     builder.node(name="ensemble2") \
#         .operator(op_code="ENSEMBLE") \
#         .params(model_name="gpt-4-turbo", count=2) \
#         .build()
#
#     builder.node(name="final_judge") \
#         .operator(op_code="JUDGE") \
#         .params(model_name="gpt-4o") \
#         .inputs("ensemble1", "ensemble2") \
#         .build()
#
#     graph: NoNGraphData = builder.build()
#
#     service: GraphExecutorService = GraphExecutorService(max_workers=4)
#     input_data: Dict[str, Any] = {"query": "What is the capital of France?"}
#
#     # Execute the graph.
#     result: Dict[str, Any] = service.run(graph_data=graph, input_data=input_data)
#     logging.info("Final result from DSL-built graph: %s", result)
